{% from "helper_macros.j2" import call_cmd_signature, var_to_any, var_to_cpp, print_template_info, cpp_type, print_spdx_line %}
{{ print_spdx_line('Apache-2.0') }}
#ifndef {{ info.hpp_guard }}
#define {{ info.hpp_guard }}

{{ print_template_info('1.0.0') }}

#include <framework/ModuleAdapter.hpp>

class {{ info.class_name }} {
public:
    {{ info.class_name }}(Everest::ModuleAdapter* adapter, const std::string& requirement_id, const uint64_t idx) : _adapter(adapter), _requirement_id(requirement_id), _idx(idx){};

    {% if not vars %}
    // this interface does not export any variables to subscribe to
    {% else %}
    // variables available for subscription
    {% for var in vars %}
    void subscribe_{{ var.name }}(const std::function<void({{ cpp_type(var) }})>& listener) {
        ValueCallback cb = [listener](const Value& value) {
            if (value.type() != typeid({{ cpp_type(var) }})) {
                {# FIXME (aw): shouldn't this check be already made inside everest? #}
                EVLOG(error) << "Callback for variable '{{ var.name }}' in interface '{{ info.interface }}' has wrong type!";
            }
            auto native_value = {{ var_to_cpp(var) }}(value);
            listener(native_value);
        };
        _adapter->subscribe(_requirement_id, _idx, "{{ var.name }}", cb);
    }
    {% if not loop.last %}

    {% endif %}
    {% endfor %}
    {% endif %}

    {% if not cmds %}
    // this interface does not export any commands to call
    {% else %}
    // commands available to call
    {% for cmd in cmds %}
    {{ call_cmd_signature(cmd) }} {
        Parameters args;
        {% for arg in cmd.args %}
        args["{{ arg.name }}"] = {{ var_to_any(arg, arg.name) }};
        {% endfor %}
        Result result = _adapter->call(_requirement_id, _idx, "{{ cmd.name }}", args);
        {% if cmd.result %}
        auto retval = {{ var_to_cpp(cmd.result) }}(result.get());

        return retval;
        {% endif %}
    }
    {% if not loop.last %}

    {% endif %}
    {% endfor %}
    {% endif %}

private:
    Everest::ModuleAdapter* const _adapter;
    const std::string _requirement_id;
    const uint64_t _idx;
};

#endif // {{ info.hpp_guard }}
